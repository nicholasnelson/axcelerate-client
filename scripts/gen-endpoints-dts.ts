import { mkdirSync, writeFileSync } from "node:fs";
import path from "node:path";
import { Project, SyntaxKind } from "ts-morph";

type ClassRef = { importPath: string; className: string; alias: string };
type Node = { classRef?: ClassRef; children: Map<string, Node> };

const noExt = (p: string) => p.replace(/\.(mts|cts|ts|tsx|js|jsx)$/i, "");
const posixRel = (from: string, to: string) =>
	path.posix.normalize(path.relative(from, to).split(path.sep).join("/"));

export async function generateEndpointsDts(
	project: Project,
	opts?: {
		root?: string;
		allFile?: string;
		outDir?: string;
		outFile?: string;
	},
) {
	const ROOT = opts?.root ?? path.resolve(process.cwd(), "src");
	const ALL_FILE = opts?.allFile ?? path.join(ROOT, "resources", "_all.ts");
	const OUT_DIR = opts?.outDir ?? path.join(ROOT, "types");
	const OUT_FILE = opts?.outFile ?? path.join(OUT_DIR, "endpoints.d.ts");

	const rootNode: Node = { children: new Map() };

	const allSf =
		project.getSourceFile(ALL_FILE) ?? project.addSourceFileAtPath(ALL_FILE);

	const resourceFiles = allSf
		.getImportDeclarations()
		.map((d) => d.getModuleSpecifierSourceFile())
		.filter((sf): sf is NonNullable<typeof sf> => !!sf);

	const aliasMap = new Map<string, string>();
	const aliasUsed = new Set<string>();
	const makeAlias = (className: string, importPath: string) => {
		const key = `${importPath}|${className}`;
		if (aliasMap.has(key)) return aliasMap.get(key)!;
		let alias = className,
			i = 1;
		while (aliasUsed.has(alias)) alias = `${className}_${i++}`;
		aliasUsed.add(alias);
		aliasMap.set(key, alias);
		return alias;
	};

	const imports: ClassRef[] = [];
	for (const sf of resourceFiles) {
		for (const cls of sf.getClasses()) {
			const dec = cls.getDecorators().find((d) => d.getName() === "endpoint");
			if (!dec) continue;
			const call = dec.getCallExpression();
			const arg = call?.getArguments()[0];
			if (!arg || arg.getKind() !== SyntaxKind.StringLiteral) continue;

			const pathStr = (arg.getText() || "").slice(1, -1).trim();
			if (!pathStr) continue;

			const className = cls.getName() || "default";
			const importPath = posixRel(
				path.join(ROOT, "types"),
				noExt(sf.getFilePath()),
			);
			const alias = makeAlias(className, importPath);
			const ref: ClassRef = { importPath, className, alias };
			imports.push(ref);

			// build tree
			let node = rootNode;
			for (const seg of pathStr.split("/").filter(Boolean)) {
				if (!node.children.has(seg))
					node.children.set(seg, { children: new Map() });
				node = node.children.get(seg)!;
			}
			node.classRef = ref;
		}
	}

	const buildType = (n: Node): string => {
		const base = n.classRef ? n.classRef.alias : "";
		const entries = [...n.children.entries()];
		const child = entries.length
			? `{ ${entries.map(([k, v]) => `${k}: ${buildType(v)}`).join("; ")} }`
			: "";
		if (base && child) return `${base} & ${child}`;
		return base || child || "{}";
	};

	const props = [...rootNode.children.entries()]
		.map(([k, v]) => `\t\t${k}: ${buildType(v)};`)
		.join("\n");

	const header = `/* Auto-generated by scripts/gen-endpoints-dts.ts. Do not edit. */\n`;
	const importLines =
		imports
			.sort((a, b) =>
				(a.importPath + a.className).localeCompare(b.importPath + b.className),
			)
			.map(
				({ importPath, className, alias }) =>
					`import type { ${className}${className === alias ? "" : ` as ${alias}`} } from "${importPath}";`,
			)
			.join("\n") + (imports.length ? "\n\n" : "");

	const body =
		`declare module "axcelerate-client" {\n` +
		`\tinterface AxcelerateClient {\n` +
		`${props}\n` +
		`\t}\n` +
		`}\n` +
		`export {};\n`;

	mkdirSync(OUT_DIR, { recursive: true });
	writeFileSync(OUT_FILE, header + importLines + body);
	console.log(`Wrote ${posixRel(process.cwd(), OUT_FILE)}`);
}
